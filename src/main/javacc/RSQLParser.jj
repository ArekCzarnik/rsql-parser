/*
 * The MIT License
 *
 * Copyright 2013 Jakub Jirutka <jakub@jirutka.cz>.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

options {
    LOOKAHEAD = 1;
    CHOICE_AMBIGUITY_CHECK = 2;
    OTHER_AMBIGUITY_CHECK = 1;
    STATIC = false;
    DEBUG_PARSER = true;
    DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
    ERROR_REPORTING = true;
    JAVA_UNICODE_ESCAPE = false;
    UNICODE_INPUT = true;
    IGNORE_CASE = false;
    USER_TOKEN_MANAGER = false;
    USER_CHAR_STREAM = false;
    BUILD_PARSER = true;
    BUILD_TOKEN_MANAGER = true;
    SANITY_CHECK = true;
    FORCE_LA_CHECK = false;
}

PARSER_BEGIN(RSQLParser)

package cz.jirutka.rsql.parser;

import cz.jirutka.rsql.parser.model.Comparison;
import cz.jirutka.rsql.parser.model.ComparisonExpression;
import cz.jirutka.rsql.parser.model.Expression;
import cz.jirutka.rsql.parser.model.Logical;
import cz.jirutka.rsql.parser.model.LogicalExpression;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <b>Parser of RSQL (RESTful Service Query Language)</b>
 *
 * <p>RSQL is a language designed for searching entries in RESTful services. 
 * It's based on URI-friendly syntax 
 * <a href="http://tools.ietf.org/html/draft-nottingham-atompub-fiql-00">
 * FIQL</a> (Feed Item Query Language), so it can be used for parsing FIQL 
 * as well.</p>
 *
 * <p><b>Grammar</b>
 * 
 * <pre>{@code
 *  expression           = [ "(" ],
 *                        ( constraint | expression ),
 *                        [ logical-operator, ( constraint | expression ) ],
 *                        [ ")" ];
 * constraint           = selector, comparison-operator, argument;
 *
 * logical-operator     = ";" | " and " | "," | " or ";
 * comparison-operator  = "==" | "=" | "!=" | "=lt=" | "<" | "=le=" | "<=" | 
 *                        "=gt=" | ">" | "=ge=" | ">=";
 *
 * selector             = qname, { ("/" | "."), qname };
 * qname                = identifier, [ ":", identifier ];
 * identifier           = ? ["a"-"z","A"-"Z","_","0"-"9","-"]+ ?
 *
 * argument             = arg_ws | arg_sq | arg_dq;
 * argument-ws          = ? ( ~["(", ")", ";", ",", " "] )+ ?;
 * argument-sq          = ? "'" ~["'"]+ "'" ?;
 * argument-dq          = ? "\"" ~["\""]+ "\"" ?;
 * }</pre></p>
 *
 * <b>Semantics</b>
 * <p>Logical operators:
 * <ul>
 *   <li>Logical AND : ";" or " and "</li>
 *   <li>Logical OR : "," or " or "</li>
 * </ul></p>
 *
 * <p>Comparison operators:
 * <ul>
 *   <li>Equal to : "==" or "="
 *   <li>Not equal to : "!="
 *   <li>Less than : "=lt=" or "<"
 *   <li>Less than or equal to : "=le=" or "<="
 *   <li>Greater than operator : "=gt=" or ">"
 *   <li>Greater than or equal to: "=ge=" or ">="
 * </ul></p>
 *
 * <p>Generated by JavaCC 5.0</p>
 *
 * @version 1.0
 * @author Jakub Jirutka <jakub@jirutka.cz>
 */
public class RSQLParser {

    private static final Logger LOG = LoggerFactory.getLogger(RSQLParser.class);
    public static final String ENCODING = "UTF-8";

    /** 
     * Parse given query expression and build query tree. 
     *
     * @param expression
     * @return query tree
     */
    public static Expression parse(String expression) throws ParseException, TokenMgrError {
        InputStream input;
        try {
            input = new ByteArrayInputStream(expression.getBytes(ENCODING));
        } catch (UnsupportedEncodingException ex) {
            throw new IllegalArgumentException(ex);
        }

        RSQLParser parser = new RSQLParser(input, ENCODING);

        if (!LOG.isTraceEnabled()) {
            parser.disable_tracing();
        }

        return parser.input();
    }
}

PARSER_END(RSQLParser)


TOKEN: /* SEPARATORS */ {
    < LPAREN: "(" >
  | < RPAREN: ")" >
}

TOKEN: /* OPERATORS */ {
    < AND: ( ";" | " and " ) >
  | < OR: ( "," | " or " ) >
}

TOKEN: /* COMPARISONS */ {
    < EQ: ( "=" | "==" ) > :ARG_STATE
  | < GT: ( ">" | "=gt=" ) > :ARG_STATE
  | < LT: ( "<" | "=lt=" ) > :ARG_STATE
  | < NE: "!=" > :ARG_STATE
  | < GE: ( ">=" | "=ge=" ) > :ARG_STATE
  | < LE: ( "<=" | "=le=" ) > :ARG_STATE
}

TOKEN: /* SELECTOR */ {
    < SELECTOR: <QNAME> ( ["/", "."] <QNAME> )* >
  | < #QNAME: <IDENTIFIER> (":" <IDENTIFIER> )? >
  | < #IDENTIFIER: ( ["a"-"z","A"-"Z","_","0"-"9","-"] )+ >
}

<ARG_STATE> TOKEN : {
    < ARGUMENT: ( ~["(", ")", ";", ",", " "] )+ 
                | ( "'" ( ~["'"] )+ "'" ) | ( "\"" ( ~["\""] )+ "\"" ) > :DEFAULT
}

/** {@code input -> disjunction } */
Expression input(): {
    final Expression exp;
}
/*-expansions-*/ {
    exp = disjunction() <EOF> {
        return exp;
    }
}

/** {@code disjunction -> conjunction ( <OR> disjunction )? } */
Expression disjunction(): {
    Expression left = null;
    Expression right = null;
}
/*-expansions-*/ {
    left = conjunction() {
    }
    (   <OR> right = disjunction() {
        } 
    )?

    {
        if (right == null) {
            return left;
        } else {
            return new LogicalExpression(left, Logical.OR, right);
        }
    }
}

/** {@code conjunction -> constraint ( <AND> conjunction )? } */
Expression conjunction(): {
    Expression left = null;
    Expression right = null;
}
/*-expansions-*/ {
    left = constraint() {
    }
    (   <AND> right = conjunction() {
        } 
    )?

    {
        if (right == null) {
            return left;
        } else {
            return new LogicalExpression(left, Logical.AND, right);
        }
    }
}

/** 
 * {@code constraint -> <SELECTOR> <COMPARISON> <ARGUMENT> 
 *                      | <LPAREN> disjunction <RPAREN> } 
 */
Expression constraint(): {
    final String sel;
    final Comparison op;
    final String arg;
    final Expression exp;
}
/*-expansions-*/ {
    ( sel = selector() op = comparison() arg = argument() ) {
        return new ComparisonExpression(sel, op, arg);
    }

    | ( <LPAREN> exp = disjunction() <RPAREN> ) {
        return exp;
    }
}

/** 
 * {@code 
 * <COMPARISON> : ("=="|"=lt="|"=le="|"=gt="|"=ge="|"="|"!="|"<"|"<="|">"|">=") 
 * }
 */
Comparison comparison(): {
    final Token t;
}
/*-expansions-*/ {
    ( t = <EQ> | t = <GT> | t = <LT> | t = <NE> | t = <GE> | t = <LE> ) {
        switch (t.kind) {
            case RSQLParserConstants.EQ : return Comparison.EQUAL;
            case RSQLParserConstants.NE : return Comparison.NOT_EQUAL;
            case RSQLParserConstants.GT : return Comparison.GREATER_THAN;
            case RSQLParserConstants.GE : return Comparison.GREATER_EQUAL;
            case RSQLParserConstants.LT : return Comparison.LESS_THAN;
            case RSQLParserConstants.LE : return Comparison.LESS_EQUAL;
            default : throw new ParseException("Missing comparison operator in enum Comparison");
        }
    }
}

/** 
 * <pre>{@code
 * <SELECTOR> : <#QNAME> ( ["/","."] <#QNAME> )*
 *   <#QNAME> : <#IDENTIFIER> (":" <#IDENTIFIER> )?
 *   <#IDENTIFIER> : ( ["a"-"z","A"-"Z","_","0"-"9","-"] )+ 
 * }</pre> 
 */
String selector(): {
    final Token t;
}
/*-expansions-*/ {
    t = <SELECTOR> {
        return t.image;
    }
}

/** 
 * {@code
 * <ARGUMENT> : (~["(",")",";",","," "])+ | ("'"(~["'"])+"'") | ("\""(~["\""] )+"\"") 
 * }
 */
String argument(): {
    final Token t;
}
/*-expansions-*/ {
    t = <ARGUMENT> {
        if (t.image.startsWith("\"") || t.image.startsWith("'")) {
            //remove quotes
            return t.image.substring(1, t.image.length() -1);
        }
        return t.image;
    }
}
